<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="c9815d57-a74b-4bdb-b848-aeb9d1e73232" name="Default" comment="" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="handler.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/flexiana/handler.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="255">
              <caret line="15" column="16" lean-forward="false" selection-start-line="15" selection-start-column="16" selection-end-line="15" selection-end-column="16" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="handler_test.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/test/flexiana/handler_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="333">
              <caret line="73" column="31" lean-forward="false" selection-start-line="73" selection-start-column="31" selection-end-line="73" selection-end-column="31" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="68">
              <caret line="4" column="0" lean-forward="false" selection-start-line="4" selection-start-column="0" selection-end-line="4" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="scramble_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/flexiana/scramble_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="-553">
              <caret line="8" column="56" lean-forward="false" selection-start-line="8" selection-start-column="56" selection-end-line="8" selection-end-column="56" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="scramble.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/flexiana/scramble.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="317">
              <caret line="62" column="0" lean-forward="true" selection-start-line="62" selection-start-column="0" selection-end-line="62" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Test Namespace" />
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>char-counts-sufficient</find>
      <find>huge-string</find>
      <find>goal</find>
      <find>resp!!</find>
      <find>(:body response)</find>
      <find>-see</find>
    </findStrings>
    <replaceStrings>
      <replace>char-counts-satisfied</replace>
      <replace>make-random-string</replace>
      <replace>needed</replace>
      <replace>(body-&gt;map response)</replace>
    </replaceStrings>
    <dirStrings>
      <dir>$PROJECT_DIR$/src/flexiana</dir>
    </dirStrings>
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/test/flexiana/scramble_test.clj" />
        <option value="$PROJECT_DIR$/src/flexiana/handler.clj" />
        <option value="$PROJECT_DIR$/src/flexiana/scramble.clj" />
        <option value="$PROJECT_DIR$/test/flexiana/handler_test.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="166" />
    <option name="y" value="84" />
    <option name="width" value="1442" />
    <option name="height" value="909" />
  </component>
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="flexiana-service" type="b2602c69:ProjectViewProjectNode" />
              <item name="flexiana-service" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="flexiana-service" type="b2602c69:ProjectViewProjectNode" />
              <item name="flexiana-service" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="flexiana-service" type="b2602c69:ProjectViewProjectNode" />
              <item name="flexiana-service" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="flexiana" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="flexiana-service" type="b2602c69:ProjectViewProjectNode" />
              <item name="flexiana-service" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="flexiana-service" type="b2602c69:ProjectViewProjectNode" />
              <item name="flexiana-service" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="flexiana" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="AndroidView" />
      <pane id="PackagesPane" />
      <pane id="Scope" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="preferences.sourceCode.Clojure" />
    <property name="cursive.last.file.extension./Users/kennethtilton/flexiana/test" value="clj" />
    <property name="cursive.last.file.extension./Users/kennethtilton/flexiana/src" value="clj" />
    <property name="SearchEverywhereHistoryKey" value="&#9;FILE&#9;file:///Users/kennethtilton/flexiana/src/flexiana/scramble.clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/src/flexiana" />
  </component>
  <component name="ReplState" timestamp="1530850565440">{:repl-history {:ide [], :local [{:command &quot;(defn scramble?\n  \&quot;Returns whether the goal string can be constructed\n  from characters in the source string, without re-use.\n\n  Developed in contemplation of a huge source string\n  where computing full frequencies is expensive. Instead\n  we walk the source string checking after each hit if\n  all counts have been satisfied and stopping if so.\n\n  Count is not checked to avoid one pass.\&quot;\n\n  [source goal]\n\n  (and\n    ;;(&lt; (count goal) (count source))\n    (let [needed (transient (frequencies goal))]\n      (some (fn [c]\n              (when-let [gct (get needed c)]\n                (let [new (dec gct)]\n                  (if (zero? new)\n                    (do\n                      (dissoc! needed dissoc c)\n                      (zero? (count needed)))\n                    (do\n                      (assoc! needed c new)\n                      nil)))))\n        source))))&quot;, :offset 872, :ns &quot;flexiana.scramble&quot;} {:command &quot;(prn\n  (time (scramble? huge-am \&quot;yobaxzokdmba\&quot;)))&quot;, :offset 49, :ns &quot;flexiana.scramble&quot;} {:command &quot;(time (scramble? huge-m (huge-string 2000 \&quot;yepzaxourqkoz\&quot;)))&quot;, :offset 60, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(time (scramble? huge-m (huge-string 2000 \&quot;yepzaxourqko\&quot;)))&quot;, :offset 59, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(time (scramble? huge-am (huge-string 2000 \&quot;yepzaxourqko\&quot;)))&quot;, :offset 60, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(Date.getTime)&quot;, :offset 14, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(.getTime (Date.))&quot;, :offset 18, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(System/currentTimeMillis) &quot;, :offset 27, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn now [] (System/currentTimeMillis))&quot;, :offset 40, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(deftest speed-check\n  (testing \&quot;under 100ms for miss against million char source, faster for hit\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;)))\n      (is (&gt; 100 )))))&quot;, :offset 195, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(deftest speed-check\n  (testing \&quot;under 100ms for miss against million char source, faster for hit\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;)))\n      (is (&gt; 100 (- (now) start))))))&quot;, :offset 210, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(deftest speed-check\n  (testing \&quot;under 100ms for miss against million char source\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;)))\n      (is (&gt; 100 (- (now) start)))))\n  (testing \&quot;under 5ms for hit against million char source\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;)))\n      (prn :delta (- (now) start))\n      (is (&gt; 5 (- (now) start))))))&quot;, :offset 397, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(deftest speed-check\n  (testing \&quot;under 100ms for miss against million char source\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;)))\n      (is (&gt; 100 (- (now) start)))))\n  (testing \&quot;under 5ms for hit against million char source\&quot;\n    (let [start (now)]\n      (is (scramble? huge-m \&quot;yobaxokdmba\&quot;))\n      (prn :delta (- (now) start))\n      (is (&gt; 5 (- (now) start))))))&quot;, :offset 390, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn scramble?\n  \&quot;Returns whether the goal string can be constructed\n  from characters in the source string, without re-use.\n\n  Developed in contemplation of a huge source string\n  where computing full frequencies is expensive. Instead\n  we walk the source string checking after each hit if\n  all counts have been satisfied and stopping if so.\&quot;\n\n  [source goal]\n\n  (and\n    (&lt;= (count goal) (count source))\n    (let [needed (transient (frequencies goal))]\n      (some (fn [c]\n              (when-let [gct (get needed c)]\n                (let [new (dec gct)]\n                  (if (zero? new)\n                    (do\n                      (dissoc! needed dissoc c)\n                      (zero? (count needed)))\n                    (do\n                      (assoc! needed c new)\n                      nil)))))\n        source))))&quot;, :offset 828, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble?\n  \&quot;Returns whether the goal string can be constructed\n  from characters in the source string, without re-use.\n\n  Developed in contemplation of a huge source string\n  where computing full frequencies is expensive. Instead\n  we walk the source string checking after each hit if\n  all counts have been satisfied and stopping if so.\&quot;\n\n  [source goal]\n\n  (or (str/blank? goal)\n    (and\n      (&lt;= (count goal) (count source))\n      (let [needed (transient (frequencies goal))]\n        (some (fn [c]\n                (when-let [gct (get needed c)]\n                  (let [new (dec gct)]\n                    (if (zero? new)\n                      (do\n                        (dissoc! needed dissoc c)\n                        (zero? (count needed)))\n                      (do\n                        (assoc! needed c new)\n                        nil)))))\n          source)))))&quot;, :offset 881, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble? \&quot;\&quot; \&quot;\&quot;)&quot;, :offset 17, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble? \&quot;xxx\&quot; \&quot;\&quot;)&quot;, :offset 20, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble?\n  \&quot;Returns whether the goal string can be constructed\n  from characters in the source string, without re-use.\n\n  Developed in contemplation of a huge source string\n  where computing full frequencies is expensive. Instead\n  we walk the source string checking after each hit if\n  all counts have been satisfied and stopping if so.\&quot;\n\n  [source goal]\n\n  (or (str/blank? goal)\n    (and\n      (&lt;= (count goal) (count source))\n      (let [needed (transient (frequencies goal))]\n        (some (fn [c]\n                (when-let [gct (get needed c)]\n                  (let [new (dec gct)]\n                    (if (zero? new)\n                      (do\n                        (dissoc! needed dissoc c)\n                        (zero? (count needed)))\n                      (do\n                        (assoc! needed c new)\n                        nil)))))\n          source)))\n    false))&quot;, :offset 891, :ns &quot;flexiana.scramble&quot;} {:command &quot;(deftest scramble-test\n  (testing \&quot;empty strings\&quot;\n    (is (scramble? \&quot;\&quot; \&quot;\&quot;))\n    (is (scramble? \&quot;technically\&quot; \&quot;\&quot;))\n    (is (= false (scramble? \&quot;\&quot; \&quot;unlikely\&quot;))))\n\n  (testing \&quot;positive exact\&quot;\n    (is (scramble? \&quot;world\&quot; \&quot;world\&quot;))\n    (is (scramble? \&quot;dlorw\&quot; \&quot;world\&quot;)))\n\n  (testing \&quot;positive extra source\&quot;\n    (is (scramble? \&quot;rekqodlw\&quot; \&quot;world\&quot;))\n    (is (scramble? \&quot;cedewaraaossoqqyt\&quot; \&quot;codewars\&quot;)))\n\n  (testing \&quot;negative missing letter\&quot;\n    (is (= false (scramble? \&quot;katas\&quot; \&quot;steak\&quot;))))\n\n  (testing \&quot;negative insufficient count\&quot;\n    (is (= false (scramble? \&quot;kaetasjjj\&quot; \&quot;steeak\&quot;)))))&quot;, :offset 575, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(deftest speed-check\n  (testing \&quot;under 100ms for miss against million char source\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;))) ;; \&quot;z\&quot;!\n      (prn :elapsed (- (now) start))\n      (is (&gt; 100 (- (now) start)))))\n  (testing \&quot;under 5ms for hit against million char source\&quot;\n    (let [start (now)]\n      (is (scramble? huge-m \&quot;yobaxokdmba\&quot;))\n      (is (&gt; 5 (- (now) start))))))&quot;, :offset 400, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn scramble?\n  \&quot;Returns whether the goal string can be constructed\n  from characters in the source string, without re-use.\n\n  Empty strings are considered constructable.\&quot;\n\n  ; Developed in contemplation of a huge source string\n  ; where computing full frequencies is expensive. (Simpler\n  ; approach took frequencies of both strings and compared\n  ; counts.)\n  ;\n  ; Instead we walk the source string checking after each hit if\n  ; all counts have been satisfied and stopping if so.\n  ;\n  ; The \&quot;all satisfied\&quot; check is simply for an empty \&quot;needed map'.\n  ; Satisfied letter counts drop that letter from the \&quot;needed\&quot;\n  ; map to short-circuit further checking of that letter.\n  ;\n\n  [source goal]\n\n  (or (str/blank? goal)\n    (and\n      ;;(&lt;= (count goal) (count source))\n      (let [needed (transient (frequencies goal))]\n        (some (fn [c]\n                (when-let [gct (get needed c)]\n                  (let [new (dec gct)]\n                    (if (zero? new)\n                      (do\n                        (dissoc! needed dissoc c)\n                        (zero? (count needed)))\n                      (do\n                        (assoc! needed c new)\n                        nil)))))\n          source)))\n    false))&quot;, :offset 1229, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (blank? b)\n    (let [af (frequencies a)\n          bf (frequencies b)]\n      (and\n        (set/subset? (keys b) (keys a))\n        (every? (fn [b ct]\n                 (&lt;= ct (get af b))) bf)))))&quot;, :offset 224, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (str/blank? b)\n    (let [af (frequencies a)\n          bf (frequencies b)]\n      (and\n        (set/subset? (keys b) (keys a))\n        (every? (fn [b ct]\n                 (&lt;= ct (get af b))) bf)))))&quot;, :offset 228, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble? \&quot;booya\&quot; \&quot;\&quot;)&quot;, :offset 22, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (str/blank? b)\n    (let [af (frequencies a)\n          bf (frequencies b)]\n      (and\n        (set/subset? (set (keys b)) (set (keys a)))\n        (every? (fn [b ct]\n                 (&lt;= ct (get af b))) bf)))))&quot;, :offset 240, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (str/blank? b)\n    (let [af (frequencies a)\n          bf (frequencies b)]\n      (and\n        (set/subset? (set (keys b)) (set (keys a)))\n        (every? (fn [b ct]\n                  (prn :b b ct)\n                 (&lt;= ct (get af b))) bf)))))&quot;, :offset 272, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (str/blank? b)\n    (let [af (frequencies a)\n          bf (frequencies b)]\n      \n      (and\n        (set/subset? (set (keys bf)) (set (keys af)))\n        (every? (fn [b ct]\n                  \n                 (&lt;= ct (get af b))) bf)))))&quot;, :offset 268, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble? \&quot;booya\&quot; \&quot;d\&quot;)&quot;, :offset 23, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (str/blank? b)\n    (let [af (frequencies a)\n          bf (frequencies b)]\n      \n      (and\n        (set/subset? (set (keys bf)) (set (keys af)))\n        (every? (fn [[b ct]]\n                  \n                 (&lt;= ct (get af b))) bf)))))&quot;, :offset 270, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble? \&quot;booya\&quot; \&quot;b\&quot;)&quot;, :offset 23, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble? \&quot;booya\&quot; \&quot;bd\&quot;)&quot;, :offset 24, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (str/blank? b)\n    (let [af (frequencies a)\n          bf (frequencies b)]\n      \n      (and\n        (set/subset? (set (keys bf)) (set (keys af)))\n        (every? (fn [[b ct]]\n                 (&lt;= ct (get af b))) bf)))))&quot;, :offset 251, :ns &quot;flexiana.scramble&quot;} {:command &quot;(deftest speed-check\n  (testing \&quot;under 100ms for miss against million char source\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;))) ;; \&quot;z\&quot;!\n      (prn :elapsed (- (now) start))\n      (is (&gt; 100 (- (now) start)))))\n  (testing \&quot;under 5ms for hit against million char source\&quot;\n    (let [start (now)]\n      (is (scramble? huge-m \&quot;yobaxokdmba\&quot;))\n      (prn :elapsed (- (now) start))\n      (is (&gt; 5 (- (now) start))))))&quot;, :offset 437, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(deftest speed-check\n  (testing \&quot;under 100ms for miss against million char source\&quot;\n    (let [start (now)]\n      (is (not (scramble? huge-m \&quot;yobaxozkdmba\&quot;))) ;; \&quot;z\&quot;!\n      ;; (prn :elapsed (- (now) start))\n      (is (&gt; 100 (- (now) start)))))\n  (testing \&quot;under 5ms for hit against million char source\&quot;\n    (let [start (now)]\n      (is (scramble? huge-m \&quot;yobaxokdmba\&quot;))\n      ;; (prn :elapsed (- (now) start))\n      (is (&gt; 5 (- (now) start))))))&quot;, :offset 443, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(def ascii-base (int \\a))&quot;, :offset 25, :ns &quot;flexiana.scramble&quot;} {:command &quot;ascii-base&quot;, :offset 10, :ns &quot;flexiana.scramble&quot;} {:command &quot;(def alpa-freq [word]\n  (let [wct (count word)]\n  (loop [i 0\n         f (transient (int-array 26 0))]\n    (if (&gt; i wct)\n      (persistent! f) ;; caller expects transient\n      (recur (inc i)\n        (update! f (- (int (.charAt word i)) ascii-base) inc))))))&quot;, :offset 257, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpa-freq [word]\n  (let [wct (count word)]\n  (loop [i 0\n         f (transient (int-array 26 0))]\n    (if (&gt; i wct)\n      (persistent! f) ;; caller expects transient\n      (recur (inc i)\n        (update! f (- (int (.charAt word i)) ascii-base) inc))))))&quot;, :offset 258, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpa-freq [word]\n  (let [wct (count word)]\n  (loop [i 0\n         f (transient (int-array 26 0))]\n    (if (&gt; i wct)\n      (persistent! f) ;; caller expects transient\n      (recur\n        (inc i)\n        (let [off (- (int (.charAt word i)) ascii-base)]\n          (assoc! f offset (inc (get f offset)))))))))&quot;, :offset 311, :ns &quot;flexiana.scramble&quot;} {:command &quot;(alphs-frew \&quot;booya\&quot;)&quot;, :offset 20, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpa-freq [word]\n  (let [wct (count word)]\n  (loop [i 0\n         f (transient (int-array 26 0))]\n    (if (&gt; i wct)\n      (persistent! f) ;; caller expects transient\n      (recur\n        (inc i)\n        (let [offset (- (int (.charAt word i)) ascii-base)]\n          (assoc! f offset (inc (get f offset)))))))))&quot;, :offset 314, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [wct (count word)]\n  (loop [i 0\n         f (transient (int-array 26 0))]\n    (if (&gt; i wct)\n      (persistent! f) ;; caller expects transient\n      (recur\n        (inc i)\n        (let [offset (- (int (.charAt word i)) ascii-base)]\n          (assoc! f offset (inc (get f offset)))))))))&quot;, :offset 315, :ns &quot;flexiana.scramble&quot;} {:command &quot;(def wx (int-array 26 0))&quot;, :offset 25, :ns &quot;flexiana.scramble&quot;} {:command &quot;wx&quot;, :offset 2, :ns &quot;flexiana.scramble&quot;} {:command &quot;(aset-int wx 7 42)&quot;, :offset 18, :ns &quot;flexiana.scramble&quot;} {:command &quot;(into [] wx)&quot;, :offset 12, :ns &quot;flexiana.scramble&quot;} {:command &quot;(update wx 1 3)&quot;, :offset 15, :ns &quot;flexiana.scramble&quot;} {:command &quot;(update! wx 1 3)&quot;, :offset 16, :ns &quot;flexiana.scramble&quot;} {:command &quot;(assoc wx 1 3)&quot;, :offset 14, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [wct (count word)]\n    (loop [i 0\n           f (int-array 26 0)]\n      (doseq [wc word]\n        (let [offset (- (int (.charAt word i)) ascii-base)]\n          (aset-int f offset (inc (get f offset))))))))&quot;, :offset 234, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [freq (int-array 26 0)]\n      (doseq [wc word]\n        (let [offset (- (int (.charAt word i)) ascii-base)]\n          (aset-int f offset (inc (get f offset)))))))&quot;, :offset 192, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [freq (int-array 26 0)]\n      (doseq [wc word]\n        (let [offset (- (int wc) ascii-base)]\n          (aset-int f offset (inc (get f offset)))))))&quot;, :offset 178, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [freq (int-array 26 0)]\n      (doseq [wc word]\n        (let [offset (- (int wc) ascii-base)]\n          (aset-int freq offset (inc (get freq offset)))))))&quot;, :offset 184, :ns &quot;flexiana.scramble&quot;} {:command &quot;(alpha-freq \&quot;booya\&quot;)&quot;, :offset 20, :ns &quot;flexiana.scramble&quot;} {:command &quot;(into (alpha-freq \&quot;booya\&quot;))&quot;, :offset 27, :ns &quot;flexiana.scramble&quot;} {:command &quot;(into [] (alpha-freq \&quot;booya\&quot;))&quot;, :offset 30, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [freq (int-array 26 0)]\n      (doseq [wc word]\n        (let [offset (- (int wc) ascii-base)]\n          (aset-int freq offset (inc (get freq offset)))))\n      freq))&quot;, :offset 195, :ns &quot;flexiana.scramble&quot;} {:command &quot;(time (frequencies huge-m))&quot;, :offset 27, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [freq (int-array 26 0)]\n    (reduce (fn [x]\n              (let [offset (- (int wc) ascii-base)]\n                (aset-int freq offset (inc (get freq offset)))))\n       word)))&quot;, :offset 206, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [freq (int-array 26 0)]\n    (reduce (fn [wc]\n              (let [offset (- (int wc) ascii-base)]\n                (aset-int freq offset (inc (get freq offset)))))\n       word)))&quot;, :offset 207, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [fq (int-array 26 0)]\n    (reduce (fn [wc]\n              (let [offset (- (int wc) ascii-base)]\n                (aset-int freq offset (inc (get freq offset)))))\n       fq word)))&quot;, :offset 208, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [fq (int-array 26 0)]\n    (reduce (fn [freq wc]\n              (let [offset (- (int wc) ascii-base)]\n                (aset-int freq offset (inc (get freq offset)))))\n       fq word)))&quot;, :offset 213, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [fq (int-array 26 0)]\n    (reduce (fn [freq wc]\n              (let [offset (- (int wc) ascii-base)]\n                (aset-int freq offset (inc (get freq offset)))\n                freq))\n       fq word)))&quot;, :offset 234, :ns &quot;flexiana.scramble&quot;} {:command &quot;(into [] (alpha-freq \&quot;worldo\&quot;))&quot;, :offset 31, :ns &quot;flexiana.scramble&quot;} {:command &quot;(assoc [] 5 3)&quot;, :offset 14, :ns &quot;flexiana.scramble&quot;} {:command &quot;(assoc-in [] 5 3)&quot;, :offset 17, :ns &quot;flexiana.scramble&quot;} {:command &quot;(assoc-in [] [5] 3)&quot;, :offset 19, :ns &quot;flexiana.scramble&quot;} {:command &quot;(repeat 26 0)&quot;, :offset 13, :ns &quot;flexiana.scramble&quot;} {:command &quot;(repeatv 26 0)&quot;, :offset 14, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (loop [wx (length word)\n         freq (transient (into [] (repeat 26 0)))]\n    (if (neg? wx)\n      (persistent! freq)\n      (recur\n        (dec wx)\n        (let [offset (- (int wc) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 279, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (loop [wx (count word)\n         freq (transient (into [] (repeat 26 0)))]\n    (if (neg? wx)\n      (persistent! freq)\n      (recur\n        (dec wx)\n        (let [offset (- (int wc) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 278, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (loop [wx (count word)\n         freq (transient (into [] (repeat 26 0)))]\n    (if (neg? wx)\n      (persistent! freq)\n      (recur\n        (dec wx)\n        (let [offset (- (int (get word wx)) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 289, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (loop [wx (count word)\n         freq (transient (into [] (repeat 26 0)))]\n    (prn :en wx (get word wx))\n    (if (neg? wx)\n      (persistent! freq)\n      (recur\n        (dec wx)\n        (let [offset (- (int (get word wx)) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 320, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (loop [wx (dec (count word))\n         freq (transient (into [] (repeat 26 0)))]\n    (prn :en wx (get word wx))\n    (if (neg? wx)\n      (persistent! freq)\n      (recur\n        (dec wx)\n        (let [offset (- (int (get word wx)) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 326, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (loop [wx (dec (count word))\n         freq (transient (into [] (repeat 26 0)))]\n    (if (neg? wx)\n      (persistent! freq)\n      (recur\n        (dec wx)\n        (let [offset (- (int (get word wx)) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 295, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (loop [wx (dec (count word))\n         freq (transient (into [] (repeat 26 0)))]\n    (if (neg? wx)\n      freq\n      (recur\n        (dec wx)\n        (let [offset (- (int (get word wx)) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 281, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn my-frequencies\n  \&quot;Returns a map from distinct items in coll to the number of times\n  they appear.\&quot;\n  {:added \&quot;1.2\&quot;\n   :static true}\n  [coll]\n  (persistent!\n    (reduce (fn [counts x]\n              (assoc! counts x (inc (get counts x 0))))\n      (transient {}) coll)))&quot;, :offset 273, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(time (do (my-frequencies huge-m) nil))&quot;, :offset 39, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn my-freq\n  \&quot;Returns a map from distinct items in coll to the number of times\n  they appear.\&quot;\n  [coll]\n  (persistent!\n    (reduce (fn [counts x]\n              (assoc! counts x (inc (get counts x 0))))\n      (transient {}) coll)))&quot;, :offset 233, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(time (do (my-freq huge-m) nil))&quot;, :offset 32, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn alpha-freq [word]\n  (persistent!\n    (reduce (fn [counts c]\n              (let [offset (- (int c) ascii-base)]\n                (assoc! freq offset (inc (get freq offset)))))\n      (transient (into [] (repeat 26 0))) word))\n  #_\n  (loop [wx (dec (count word))\n         \n         freq (transient (into [] (repeat 26 0)))]\n    (if (neg? wx)\n      freq\n      (recur\n        (dec wx)\n        (let [offset (- (int (get word wx)) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 501, :ns &quot;flexiana.scramble&quot;} {:command &quot;(alpha-freq \&quot;world\&quot;)&quot;, :offset 20, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn alpha-freq [word]\n  (persistent!\n    (reduce (fn [counts c]\n              (let [offset (- (int c) ascii-base)]\n                (assoc! counts offset (inc (get counts offset)))))\n      (transient (into [] (repeat 26 0)))\n      word))\n  #_\n  (loop [wx (dec (count word))\n         \n         freq (transient (into [] (repeat 26 0)))]\n    (if (neg? wx)\n      freq\n      (recur\n        (dec wx)\n        (let [offset (- (int (get word wx)) ascii-base)]\n          (assoc! freq offset (inc (get freq offset))))))))&quot;, :offset 511, :ns &quot;flexiana.scramble&quot;} {:command &quot;(time (do (alpha-freq huge-m) nil))&quot;, :offset 35, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(time (do (frequencies huge-m) nil))&quot;, :offset 36, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn alpha-freq [word]\n  (let [ascii-base (int \\a)]\n  (persistent!\n    (reduce (fn [counts c]\n              (let [offset (- (int c) ascii-base)]\n                (assoc! counts offset (inc (get counts offset)))))\n      (transient (into [] (repeat 26 0)))\n      word))))&quot;, :offset 269, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble? [a b]\n  (or\n    (str/blank? b)\n    (let [af (alpha-freq a)\n          bf (alpha-freq b)]\n      (and\n        (set/subset? (set (keys bf)) (set (keys af)))\n        (every? (fn [[b ct]]\n                  (&lt;= ct (get af b))) bf)))))&quot;, :offset 243, :ns &quot;flexiana.scramble&quot;} {:command &quot;(time (scramble? huge-m \&quot;yobaxozkdmba\&quot;))&quot;, :offset 40, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn scramble?-alpha-freq [a b]\n  (or\n    (str/blank? b)\n    (let [af (alpha-freq a)\n          bf (alpha-freq b)]\n      (every? (fn [sct tct]\n                (&gt;= sct tct))\n        af bf))))&quot;, :offset 190, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble?-alpha-freq [source goal]\n  (or\n    (str/blank? goal)\n    (let [s-frq (alpha-freq source)\n          g-frq (alpha-freq goal)]\n      (every? (compose not neg?)\n        (map - s-frq g-frq)))))&quot;, :offset 204, :ns &quot;flexiana.scramble&quot;} {:command &quot;(defn scramble?-alpha-freq [source goal]\n  (or\n    (str/blank? goal)\n    (let [s-frq (alpha-freq source)\n          g-frq (alpha-freq goal)]\n      (every? (comp not neg?)\n        (map - s-frq g-frq)))))&quot;, :offset 201, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble?-alpha-freq \&quot;booya\&quot; \&quot;aboy\&quot;)&quot;, :offset 37, :ns &quot;flexiana.scramble&quot;} {:command &quot;(scramble?-alpha-freq \&quot;booya\&quot; \&quot;aboyz\&quot;)&quot;, :offset 38, :ns &quot;flexiana.scramble&quot;} {:command &quot;(time (scramble?-alpha-freq huge-m \&quot;yobaxozkdmba\&quot;))&quot;, :offset 51, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(time (scramble?-alpha-freq huge-m \&quot;yobaxokdmba\&quot;))&quot;, :offset 50, :ns &quot;flexiana.scramble-test&quot;} {:command &quot;(defn handle-scramble? [req]\n  (try\n    (let [{:keys [params]} req]\n      ;;(throw (Exception. \&quot;test\&quot;))\n      (cond\n        (not-every? #(contains? params %) [:source :target])\n        {:status  422\n         :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n         :body    (str {:usageError \&quot;Required params aource and/or target not provided.\&quot;})}\n\n        :default\n        (let [{:keys [source target]} params\n              result (scramble? source target)]\n          ;; todo log traffic usefully\n          {:status  200\n           :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n           :body                                            ;; (str \&quot;&lt;h1&gt;Booya:\&quot; result)\n                    (merge\n                      (select-keys params [:source :target])\n                      {:result result})})))\n\n    ;; todo log/report error usefully\n    (catch Exception e\n      {:status  500\n       :headers {\&quot;Content-Type\&quot; \&quot;text/html\&quot;}\n       :body    \&quot;Something 500 happened.\&quot;})))&quot;, :offset 968, :ns &quot;flexiana.scramble&quot;} {:command &quot;(deftest test-app\n  ;;\n  ;; we have implemented an API in which the response will contain\n  ;; the queried params and a :result key bound to true or false,\n  ;; and in which it is an error to omit :source or :target params.\n  ;;\n  (testing \&quot;main route scramblep true\&quot;\n    (let [query {:source \&quot;booya\&quot;, :target \&quot;yabo\&quot;}\n          response (app\n                     (mock/request :get \&quot;/scramblep\&quot; query))]\n      (prn response)\n      (is (= (:status response) Response-OK))\n      (is (= (:body response) (merge query {:result true})))))\n\n  (testing \&quot;main route scramblep False\&quot;\n    (let [query {:source \&quot;booya\&quot;, :target \&quot;yabbo\&quot;}\n          response (app\n                     (mock/request :get \&quot;/scramblep\&quot; query))]\n      (is (= (:status response) Response-OK))\n      (is (= (:body response) (merge query {:result false})))))\n\n  (testing \&quot;bad request1\&quot;\n    (let [response (app\n                     (mock/request :get \&quot;/scramblep\&quot;\n                       {:source \&quot;booya\&quot;}))]\n      (is (= (:status response) Unprocessable-Entity))))\n\n  (testing \&quot;bad request1\&quot;\n    (let [response (app\n                     (mock/request :get \&quot;/scramblep\&quot;\n                       {:target \&quot;yoba\&quot;}))]\n      (is (= (:status response) Unprocessable-Entity))))\n\n  (testing \&quot;bad route\&quot;\n    (let [response (app (mock/request :get \&quot;/invalid\&quot;))]\n      (is (= (:status response) Not-Found)))))&quot;, :offset 1358, :ns &quot;flexiana.handler-test&quot;} {:command &quot;(deftest test-app-mini\n  ;;\n  ;; we have implemented an API in which the response will contain\n  ;; the queried params and a :result key bound to true or false,\n  ;; and in which it is an error to omit :source or :target params.\n  ;;\n  (testing \&quot;main route scramblep true\&quot;\n    (let [query {:source \&quot;booya\&quot;, :target \&quot;yabo\&quot;}\n          response (app\n                     (mock/request :get \&quot;/scramblep\&quot; query))]\n      (prn response)\n      (is (= (:status response) Response-OK))\n      (is (= (parse-string (:body response)) (merge query {:result true}))))))&quot;, :offset 554, :ns &quot;flexiana.handler-test&quot;} {:command &quot;(deftest test-app-mini\n  ;;\n  ;; we have implemented an API in which the response will contain\n  ;; the queried params and a :result key bound to true or false,\n  ;; and in which it is an error to omit :source or :target params.\n  ;;\n  (testing \&quot;main route scramblep true\&quot;\n    (let [query {:source \&quot;booya\&quot;, :target \&quot;yabo\&quot;}\n          response (app\n                     (mock/request :get \&quot;/scramblep\&quot; query))]\n      (prn (parse-string (:body response)))\n      (is (= (:status response) Response-OK))\n      (is (= (parse-string (:body response)) (merge query {:result true}))))))&quot;, :offset 577, :ns &quot;flexiana.handler-test&quot;} {:command &quot;(deftest test-app-mini\n  ;;\n  ;; we have implemented an API in which the response will contain\n  ;; the queried params and a :result key bound to true or false,\n  ;; and in which it is an error to omit :source or :target params.\n  ;;\n  (testing \&quot;main route scramblep true\&quot;\n    (let [query {:source \&quot;booya\&quot;, :target \&quot;yabo\&quot;}\n          response (app\n                     (mock/request :get \&quot;/scramblep\&quot; query))]\n      (prn (parse-string (:body response) true))\n      (is (= (:status response) Response-OK))\n      (is (= (body-&gt;map response) (merge query {:result true}))))))&quot;, :offset 571, :ns &quot;flexiana.handler-test&quot;} {:command &quot;(deftest test-app\n  ;;\n  ;; we have implemented an API in which the response will contain\n  ;; the queried params and a :result key bound to true or false,\n  ;; and in which it is an error to omit :source or :target params.\n  ;;\n  (testing \&quot;main route scramblep true\&quot;\n    (let [query {:source \&quot;booya\&quot;, :target \&quot;yabo\&quot;}\n          response (app\n                     (mock/request :get \&quot;/scramblep\&quot; query))]\n      (prn response)\n      (is (= (:status response) Response-OK))\n      (is (= (body-&gt;map response) (merge query {:result true})))))\n\n  (testing \&quot;main route scramblep False\&quot;\n    (let [query {:source \&quot;booya\&quot;, :target \&quot;yabbo\&quot;}\n          response (app\n                     (mock/request :get \&quot;/scramblep\&quot; query))]\n      (is (= (:status response) Response-OK))\n      (is (= (body-&gt;map response) (merge query {:result false})))))\n\n  (testing \&quot;bad request no target\&quot;\n    (let [response (app\n                     (mock/request :get \&quot;/scramblep\&quot;\n                       {:source \&quot;booya\&quot;}))]\n      (is (= (:status response) Unprocessable-Entity))))\n\n  (testing \&quot;bad request no source\&quot;\n    (let [response (app\n                     (mock/request :get \&quot;/scramblep\&quot;\n                       {:target \&quot;yoba\&quot;}))]\n      (is (= (:status response) Unprocessable-Entity))))\n\n  (testing \&quot;bad non a-z source\&quot;\n    (let [response (app\n                     (mock/request :get \&quot;/scramblep\&quot;\n                       {:source \&quot;b o o y a\&quot;\n                        :target \&quot;yoba\&quot;}))]\n      (is (= (:status response) Unprocessable-Entity))))\n\n  (testing \&quot;bad non a-z target\&quot;\n    (let [response (app\n                     (mock/request :get \&quot;/scramblep\&quot;\n                       {:source \&quot;booya\&quot;\n                        :target \&quot;b y a\&quot;}))]\n      (is (= (:status response) Unprocessable-Entity))))\n\n  (testing \&quot;bad route\&quot;\n    (let [response (app (mock/request :get \&quot;/invalid\&quot;))]\n      (is (= (:status response) Not-Found)))))&quot;, :offset 1889, :ns &quot;flexiana.handler-test&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.Unnamed">
    <configuration name="Unnamed" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="flexiana" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="c9815d57-a74b-4bdb-b848-aeb9d1e73232" name="Default" comment="" />
      <created>1530617517005</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1530617517005</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="166" y="84" width="1442" height="909" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="10" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.32923833" sideWeight="0.50832176" order="11" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="false" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.20943135" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.32923833" sideWeight="0.49167824" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="7" side_tool="false" content_ui="combo" />
      <window_info id="Messages" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" x="266" y="184" width="1242" height="709" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
    </layout>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager />
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/src/flexiana/handler.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="255">
          <caret line="15" column="16" lean-forward="false" selection-start-line="15" selection-start-column="16" selection-end-line="15" selection-end-column="16" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="68">
          <caret line="4" column="0" lean-forward="false" selection-start-line="4" selection-start-column="0" selection-end-line="4" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/flexiana/scramble_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1037">
          <caret line="61" column="25" lean-forward="false" selection-start-line="61" selection-start-column="25" selection-end-line="61" selection-end-column="25" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/flexiana/scramble.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="952">
          <caret line="56" column="13" lean-forward="true" selection-start-line="56" selection-start-column="13" selection-end-line="56" selection-end-column="13" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/flexiana/handler_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="357">
          <caret line="21" column="23" lean-forward="true" selection-start-line="21" selection-start-column="23" selection-end-line="21" selection-end-column="23" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/flexiana/handler.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="255">
          <caret line="15" column="16" lean-forward="false" selection-start-line="15" selection-start-column="16" selection-end-line="15" selection-end-column="16" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/flexiana/handler_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="748">
          <caret line="44" column="0" lean-forward="false" selection-start-line="44" selection-start-column="0" selection-end-line="44" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/flexiana/scramble.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="408">
          <caret line="24" column="0" lean-forward="false" selection-start-line="24" selection-start-column="0" selection-end-line="24" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/flexiana/scramble_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1054">
          <caret line="62" column="53" lean-forward="false" selection-start-line="62" selection-start-column="53" selection-end-line="62" selection-end-column="53" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.8.0/clojure-1.8.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="134">
          <caret line="2562" column="6" lean-forward="false" selection-start-line="2562" selection-start-column="6" selection-end-line="2562" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/ring/ring-defaults/0.2.1/ring-defaults-0.2.1.jar!/ring/middleware/defaults.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="80" column="6" lean-forward="false" selection-start-line="80" selection-start-column="6" selection-end-line="80" selection-end-column="6" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="68">
          <caret line="4" column="0" lean-forward="false" selection-start-line="4" selection-start-column="0" selection-end-line="4" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/cheshire/cheshire/5.8.0/cheshire-5.8.0.jar!/cheshire/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="-123">
          <caret line="191" column="6" lean-forward="false" selection-start-line="191" selection-start-column="6" selection-end-line="191" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/flexiana/handler.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="255">
          <caret line="15" column="16" lean-forward="false" selection-start-line="15" selection-start-column="16" selection-end-line="15" selection-end-column="16" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/flexiana/scramble_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="-553">
          <caret line="8" column="56" lean-forward="false" selection-start-line="8" selection-start-column="56" selection-end-line="8" selection-end-column="56" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/flexiana/scramble.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="317">
          <caret line="62" column="0" lean-forward="true" selection-start-line="62" selection-start-column="0" selection-end-line="62" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/flexiana/handler_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="333">
          <caret line="73" column="31" lean-forward="false" selection-start-line="73" selection-start-column="31" selection-end-line="73" selection-end-column="31" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>